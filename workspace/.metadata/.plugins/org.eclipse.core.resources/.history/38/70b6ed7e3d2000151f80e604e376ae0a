package edu.nesterenko.auction.auction;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Phaser;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

import edu.nesterenko.auction.exception.LogicalException;
import edu.nesterenko.auction.participant.Participant;

public class Auction extends Thread {
	private LinkedList<Lot> lots;
	private LinkedList<Lot> finishedLots;
	private Lot currentLot;
	private Map<Participant, Integer> blockedParticipants;
	private Phaser phaser;
	private Random random;
	private ReentrantLock lockForBlockedParticipant;
	private Condition cond;
	private volatile boolean closed;
	private ReentrantLock sync;
	private Condition isBetted;	

	public Auction() {
		lots = new LinkedList<Lot>();
		finishedLots = new LinkedList<Lot>();
		lockForBlockedParticipant = new ReentrantLock();
		cond = lockForBlockedParticipant.newCondition();			
		sync = new ReentrantLock();
		isBetted = sync.newCondition();
		random = new Random();
		blockedParticipants = new ConcurrentHashMap<Participant, Integer>();
		phaser = new Phaser();
		phaser.register();
	}	
	
	public void run() {
		while(!isEmpty()) {
			System.out.println();
			currentLot = lots.removeFirst();
			phaser.arriveAndAwaitAdvance(); 
			phaser.arriveAndAwaitAdvance();
			phaser.arriveAndAwaitAdvance();			
			finishLot();
			if(isEmpty()) {
				setClosed(true);				
			}
			phaser.arriveAndAwaitAdvance();			
		}
		System.out.println(String.format("Поток: %s завершён", this.getName()));
		phaser.arriveAndDeregister();
	}
	
	private void finishLot() { 
		if(currentLot.getWinner() != null) {
			try {
				Thread.sleep(random.nextInt(500));				
				if(currentLot.isConfirmed()) {
					System.out.println(String.format("Поток %s заплатил, лот является завершённым", currentLot.getWinner().getName()));
					finishedLots.add(currentLot);
					updateblockedParticipants();
				} else {
					updateblockedParticipants();
					try {
						System.out.println(String.format("Поток %s не заплатил, лот будет переигран", currentLot.getWinner().getName()));						
						int numberOfLotsToWait = 1 + random.nextInt(2);
						System.out.println(String.format("Поток %s поток блакируется на %d хода", 
								currentLot.getWinner().getName(), numberOfLotsToWait));
						blockedParticipants.put(currentLot.getWinner(), numberOfLotsToWait);
						lots.add(new Lot(currentLot.getStartPrice(), currentLot.getLotsName()));
					} catch(LogicalException e) {
						e.printStackTrace();
					}
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			} 
		} else {
			System.out.println(String.format("Лот оказался никому не интересен и удалён"));	
		}		
	}	
	
	private void updateblockedParticipants() {
		Set<Entry<Participant, Integer>> entrySet = blockedParticipants.entrySet();
		for(Entry<Participant, Integer> entry : entrySet) {
			int value = entry.getValue() - 1;
			if(value == 0) {				
				phaser.register();
				blockedParticipants.remove(entry.getKey());
			} else {
				blockedParticipants.replace(entry.getKey(), value);
			}
		}
		lockForBlockedParticipant.lock();
		try {
			cond.signalAll();
		} finally {
			lockForBlockedParticipant.unlock();
		}
	}	
	
	private boolean checkGuilty() {
		boolean isBlocked = false;
		while(blockedParticipants.containsKey(Thread.currentThread()) && !isClosed()) {
			if(!isBlocked) {
				phaser.arriveAndDeregister();
				isBlocked = true;
				System.out.println(String.format("Поток %s является должником", Thread.currentThread().getName()));
			}						
			lockForBlockedParticipant.lock();
			try {
				cond.await();
			} catch (InterruptedException e) {				
				e.printStackTrace();
			} finally {
				lockForBlockedParticipant.unlock();
			}			
		}	
		if(isBlocked) {			
			System.out.println(String.format("Потоку %s снова доступен аукцион" , Thread.currentThread().getName()));		
			return true;
		}
		return false;
	}
	
	private void betting(Participant participant) {
		currentLot.register();
		System.out.println(String.format("Поток: %s зарегистрировался на лот: %s",  participant.getName(), currentLot.getLotsName()));
		phaser.arriveAndAwaitAdvance();				
		boolean decigion = random.nextBoolean();
		while(decigion) {	
			sync.lock();
			try {
				int bet = currentLot.getFinishPrice();
				if(currentLot.getWinner() != null) {
					bet += random.nextInt(300);
					currentLot.setFinishPrice(bet);
				}				
				currentLot.setWinner(participant);
				System.out.println(String.format("Поток: %s сделал ставку: %d", participant.getName(), bet));
				isBetted.signal();
				try {
					if(currentLot.getNumberOfParticipant() != 1) {
						isBetted.await();
					}
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			} finally {
				sync.unlock();		
			}
			decigion = (currentLot.getNumberOfParticipant() != 1)?random.nextBoolean():false;
		}			
		currentLot.deregister();
		if(currentLot.getNumberOfParticipant() == 1) {
			sync.lock();
			try {
				isBetted.signal();
			} finally {
				sync.unlock();
			}
		}
		System.out.println(String.format("Поток: %s перестал разыгрывать данный лот", participant.getName()));
	}
	
	private void pay(Participant participant) {
		if(currentLot.getWinner() == Thread.currentThread()) {
			System.out.println(String.format("Поток: %s победил", participant.getName()));	
			try {
				Thread.sleep(random.nextInt(500));
				currentLot.setConfirmed(true);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
	public void trade() {
		Participant participant = (Participant)Thread.currentThread();
		while(!isClosed()) {
			phaser.arriveAndAwaitAdvance();	
			if(!checkGuilty()) {
				betting(participant);
				phaser.arriveAndAwaitAdvance();
				pay(participant);
			}					
			phaser.arriveAndAwaitAdvance();			
		}
		System.out.println(String.format("Поток: %s завершён", participant.getName()));
		phaser.arriveAndDeregister();
	}	
	
	public void register() {
		phaser.register();
	}
	
	public void addLot(Lot lot) {
		lots.add(lot);
	}

	public Lot getCurrentLot() {		
		return currentLot;
	}	
	
	public List<Lot> getFinishedLots() {
		return Collections.unmodifiableList(finishedLots);
	}
	
	public boolean isEmpty() {
		return lots.isEmpty();
	}

	public boolean isClosed() {
		return closed;
	}

	public void setClosed(boolean closed) {
		this.closed = closed;
	}
}
