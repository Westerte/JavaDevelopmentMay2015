package edu.nesterenko.parcer.logic;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import edu.nesterenko.parcer.entity.Component;
import edu.nesterenko.parcer.entity.Composite;
import edu.nesterenko.parcer.entity.Leaf;
import edu.nesterenko.parcer.exception.LogicalException;

public class Parcer {
	private Component root = new Composite("root");
	private Map<String, List<String>> childrensMap = new HashMap<String, List<String>>();
	private Map<String, String> patternMap = new HashMap<String, String>();
	private Map<String, String> elementsTypeMap = new HashMap<String, String>();
	
	public void configure(String propertiesFilePath) throws IOException {
		Properties properties = new Properties();
		FileInputStream fis = new FileInputStream(propertiesFilePath);
		properties.load(fis);
		elementsTypeMap.put("root", "composite");
		int i = 1;
		String elementName;
		while((elementName = properties.getProperty("elem"+i+"."+"name")) != null) {
			String elementPattern = properties.getProperty("elem"+i+"."+"pattern");
			String elementType = properties.getProperty("elem"+i+"."+"type");
			String elementFather = properties.getProperty("elem"+i+"."+"father");
			patternMap.put(elementName, elementPattern);
			elementsTypeMap.put(elementName, elementType);
			List<String> childrensList = childrensMap.get(elementFather);
			if(null == childrensList) {
				childrensList = new ArrayList<String>();
				childrensList.add(elementName);
				childrensMap.put(elementFather, childrensList);
			} else {
				childrensList.add(elementName);
			}		
			i++;
		}
	}
	
	public void parce(String text) throws LogicalException {
		parce(text, root);
	}
	
	private void parce(String text, Component fatherName) throws LogicalException {
		List<String> childrensNames = childrensMap.get(fatherName.getName());
		String regEx = "";
		for(int i = 0 ; i < childrensNames.size(); i++) {
			String childrenPattern = patternMap.get(childrensNames.get(i));
			if("".equals(childrenPattern)){
				continue;
			}
			regEx += "|" + "(" + childrenPattern + ")";
		}
		regEx = regEx.substring(1);
		Pattern pattern = Pattern.compile(regEx);
		Matcher matcher = pattern.matcher(text);
		int currentStepStart = 0;
		int prevStepEnd = 0;
		while(matcher.find(currentStepStart)) {
			currentStepStart = matcher.start();
			String findedText;
			if(prevStepEnd - currentStepStart != 0) {
				findedText = text.substring(prevStepEnd, currentStepStart);
				String elementName;
				for(String children : childrensNames) {
					if(patternMap.get(children) == "") {
						elementName = children;
					} else {
						throw new LogicalException("Unidentifiable symbols siquence");
					}
				} 
				buildComponent(findedText, childrensNames, fatherName, elementName);
			}
			findedText = matcher.group();
			buildComponent(findedText, childrensNames, fatherName, false);
			prevStepEnd = matcher.end();			
		}
		int textLength = text.length();
		if(prevStepEnd - textLength != 0) {
			String findedText = text.substring(prevStepEnd, textLength);
			String elementName;
			for(String children : childrensNames) {
				if(patternMap.get(children) == "") {
					elementName = children;
				} else {
					throw new LogicalException("Unidentifiable symbols siquence");
				}
			} 
			buildComponent(findedText, childrensNames, fatherName, true);
		}
		
	}
	
	
	
	private void buildComponent(String findedText, List<String> childrens, Component father, String elementType) throws LogicalException {
		switch (elementsTypeMap.get(elementName)) {
		case "leaf":
			Component leaf = new Leaf(elementName, findedText);
			father.addComponent(leaf);
			break;
		case "composite":
			Component composite = new Composite(elementName);
			parce(findedText, composite);
			father.addComponent(composite);
			break;
		default: 
			throw new LogicalException("this element type can not be recognized");
		}
	}
	
	public Component getHierarchy() {
		return root;
	}
	
	public String reviveText() throws LogicalException {
		StringBuilder stringBuilder = new StringBuilder();
		reviveText(root, stringBuilder);
		return stringBuilder.toString();
	}
	
	private void reviveText(Component component, StringBuilder stringBuilder) throws LogicalException {
		switch(elementsTypeMap.get(component.getName())) {
		case "composite":
			for(Component children: component) {
				reviveText(children,stringBuilder);
			}
			break;
		case "leaf":
			stringBuilder.append(component.getContent());
			break;
		default:
			throw new LogicalException("this element type can not be recognized");
		}
	}
}
