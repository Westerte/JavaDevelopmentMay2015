package edu.nesterenko.parcer.logic;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import edu.nesterenko.parcer.entity.Component;
import edu.nesterenko.parcer.entity.Composite;
import edu.nesterenko.parcer.entity.Leaf;
import edu.nesterenko.parcer.exception.LogicalException;

public class Parcer {
	private Component root = new Composite("root");
	private Map<String, List<String>> childrensMap = new HashMap<String, List<String>>();
	private Map<String, String> patternMap = new HashMap<String, String>();
	private Map<String, String> elementsTypeMap = new HashMap<String, String>();
	
	public void configure(String propertiesFilePath) throws IOException {
		Properties properties = new Properties();
		FileInputStream fis = new FileInputStream(propertiesFilePath);
		properties.load(fis);
		int i = 1;
		String elementName;
		while((elementName = properties.getProperty("elem"+i+"."+"name")) != null) {
			String elementPattern = properties.getProperty("elem"+i+"."+"pattern");
			String elementType = properties.getProperty("elem"+i+"."+"type");
			String elementFather = properties.getProperty("elem"+i+"."+"father");
			patternMap.put(elementName, elementPattern);
			elementsTypeMap.put(elementName, elementType);
			List<String> childrensList = childrensMap.get(elementFather);
			if(null == childrensList) {
				childrensList = new ArrayList<String>();
				childrensList.add(elementName);
				childrensMap.put(elementFather, childrensList);
			} else {
				childrensList.add(elementName);
			}		
			i++;
		}
	}
	
	public void parce(String text) throws LogicalException {
		parce(text, root);
	}
	
	private void parce(String text, Component father) throws LogicalException {
		List<String> childrens = childrensMap.get(father.getName());
		String regEx = "";
		for(int i = 0 ; i < childrens.size(); i++) {
			String childrenPattern = patternMap.get(childrens.get(i));
			if("".equals(childrenPattern)){
				continue;
			}
			regEx += "|" + "(" + childrenPattern + ")";
		}
		regEx = regEx.substring(1);
		Pattern pattern = Pattern.compile(regEx);
		Matcher matcher = pattern.matcher(text);
		int currentStepStart = 0;
		int prevStepEnd = 0;
		while(matcher.find()) {
			currentStepStart = matcher.start();
			String findedText;
			if(prevStepEnd - currentStepStart != 0) {
				findedText = text.substring(prevStepEnd, currentStepStart);
				buildComponent(findedText, childrens, father, true);
			}
			findedText = matcher.group();
			buildComponent(findedText, childrens, father, false);
			prevStepEnd = matcher.end();			
		}
		if(prevStepEnd - currentStepStart != 0) {
			String findedText = text.substring(prevStepEnd, currentStepStart);
			buildComponent(findedText, null, father, true);
		}
		
	}
	
	private String recognizedElement(String text, List<String> childrens) {
		for(String children: childrens) {			
			String regEx = patternMap.get(children);
			if("".equals(childrenPattern)){
				continue;
			}
			if(Pattern.matches(regEx, text)) {
				return children;
			}
		}
		return null;
	}
	
	private void buildComponent(String findedText, List<String> childrens, Component father, boolean isNone) throws LogicalException {
		String elementName = (isNone)?recognizedElement(findedText, childrens):;
		switch (elementsTypeMap.get(elementName)) {
		case "leaf":
			Component leaf = new Leaf(elementName, findedText);
			father.addComponent(leaf);
			break;
		case "composite":
			Component composite = new Composite(elementName);
			parce(findedText, composite);
			father.addComponent(composite);
		default: 
			throw new LogicalException("this element type can not be recognized");
		}
	}
	
	public Component getHierarchy() {
		return root;
	}
}
